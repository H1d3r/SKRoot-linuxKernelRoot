#pragma once
#include <string.h>
#include <iostream>

#define	__AARCH64_INSN_FUNCS(abbr, mask, val)				\
static bool aarch64_insn_is_##abbr(uint32_t code)		\
{									\
	static_assert((val & ~mask) == 0, "val has bits outside mask");	\
	return (code & (mask)) == (val);				\
}									\
static uint32_t aarch64_insn_get_##abbr##_value(void)	\
{									\
	return (val);							\
}
/*
 * ARM Architecture Reference Manual for ARMv8 Profile-A, Issue A.a
 * Section C3.1 "A64 instruction index by encoding":
 * AArch64 main encoding table
 *  Bit position
 *   28 27 26 25	Encoding Group
 *   0  0  -  -		Unallocated
 *   1  0  0  -		Data processing, immediate
 *   1  0  1  -		Branch, exception generation and system instructions
 *   -  1  -  0		Loads and stores
 *   -  1  0  1		Data processing - register
 *   0  1  1  1		Data processing - SIMD and floating point
 *   1  1  1  1		Data processing - SIMD and floating point
 * "-" means "don't care"
 */
__AARCH64_INSN_FUNCS(class_branch_sys,	0x1c000000, 0x14000000)

__AARCH64_INSN_FUNCS(adr,	0x9F000000, 0x10000000)
__AARCH64_INSN_FUNCS(adrp,	0x9F000000, 0x90000000)
__AARCH64_INSN_FUNCS(prfm,	0x3FC00000, 0x39800000)
__AARCH64_INSN_FUNCS(prfm_lit,	0xFF000000, 0xD8000000)
__AARCH64_INSN_FUNCS(store_imm,	0x3FC00000, 0x39000000)
__AARCH64_INSN_FUNCS(load_imm,	0x3FC00000, 0x39400000)
__AARCH64_INSN_FUNCS(signed_load_imm, 0X3FC00000, 0x39800000)
__AARCH64_INSN_FUNCS(store_pre,	0x3FE00C00, 0x38000C00)
__AARCH64_INSN_FUNCS(load_pre,	0x3FE00C00, 0x38400C00)
__AARCH64_INSN_FUNCS(store_post,	0x3FE00C00, 0x38000400)
__AARCH64_INSN_FUNCS(load_post,	0x3FE00C00, 0x38400400)
__AARCH64_INSN_FUNCS(str_reg,	0x3FE0EC00, 0x38206800)
__AARCH64_INSN_FUNCS(str_imm,	0x3FC00000, 0x39000000)
__AARCH64_INSN_FUNCS(ldadd,	0x3F20FC00, 0x38200000)
__AARCH64_INSN_FUNCS(ldclr,	0x3F20FC00, 0x38201000)
__AARCH64_INSN_FUNCS(ldeor,	0x3F20FC00, 0x38202000)
__AARCH64_INSN_FUNCS(ldset,	0x3F20FC00, 0x38203000)
__AARCH64_INSN_FUNCS(swp,	0x3F20FC00, 0x38208000)
__AARCH64_INSN_FUNCS(cas,	0x3FA07C00, 0x08A07C00)
__AARCH64_INSN_FUNCS(ldr_reg,	0x3FE0EC00, 0x38606800)
__AARCH64_INSN_FUNCS(signed_ldr_reg, 0X3FE0FC00, 0x38A0E800)
__AARCH64_INSN_FUNCS(ldr_imm,	0x3FC00000, 0x39400000)
__AARCH64_INSN_FUNCS(ldr_lit,	0xBF000000, 0x18000000)
__AARCH64_INSN_FUNCS(ldrsw_lit,	0xFF000000, 0x98000000)
__AARCH64_INSN_FUNCS(exclusive,	0x3F800000, 0x08000000)
__AARCH64_INSN_FUNCS(load_ex,	0x3F400000, 0x08400000)
__AARCH64_INSN_FUNCS(store_ex,	0x3F400000, 0x08000000)
__AARCH64_INSN_FUNCS(stp,	0x7FC00000, 0x29000000)
__AARCH64_INSN_FUNCS(ldp,	0x7FC00000, 0x29400000)
__AARCH64_INSN_FUNCS(stp_post,	0x7FC00000, 0x28800000)
__AARCH64_INSN_FUNCS(ldp_post,	0x7FC00000, 0x28C00000)
__AARCH64_INSN_FUNCS(stp_pre,	0x7FC00000, 0x29800000)
__AARCH64_INSN_FUNCS(ldp_pre,	0x7FC00000, 0x29C00000)
__AARCH64_INSN_FUNCS(add_imm,	0x7F000000, 0x11000000)
__AARCH64_INSN_FUNCS(adds_imm,	0x7F000000, 0x31000000)
__AARCH64_INSN_FUNCS(sub_imm,	0x7F000000, 0x51000000)
__AARCH64_INSN_FUNCS(subs_imm,	0x7F000000, 0x71000000)
__AARCH64_INSN_FUNCS(movn,	0x7F800000, 0x12800000)
__AARCH64_INSN_FUNCS(sbfm,	0x7F800000, 0x13000000)
__AARCH64_INSN_FUNCS(bfm,	0x7F800000, 0x33000000)
__AARCH64_INSN_FUNCS(movz,	0x7F800000, 0x52800000)
__AARCH64_INSN_FUNCS(ubfm,	0x7F800000, 0x53000000)
__AARCH64_INSN_FUNCS(movk,	0x7F800000, 0x72800000)
__AARCH64_INSN_FUNCS(add,	0x7F200000, 0x0B000000)
__AARCH64_INSN_FUNCS(adds,	0x7F200000, 0x2B000000)
__AARCH64_INSN_FUNCS(sub,	0x7F200000, 0x4B000000)
__AARCH64_INSN_FUNCS(subs,	0x7F200000, 0x6B000000)
__AARCH64_INSN_FUNCS(madd,	0x7FE08000, 0x1B000000)
__AARCH64_INSN_FUNCS(msub,	0x7FE08000, 0x1B008000)
__AARCH64_INSN_FUNCS(udiv,	0x7FE0FC00, 0x1AC00800)
__AARCH64_INSN_FUNCS(sdiv,	0x7FE0FC00, 0x1AC00C00)
__AARCH64_INSN_FUNCS(lslv,	0x7FE0FC00, 0x1AC02000)
__AARCH64_INSN_FUNCS(lsrv,	0x7FE0FC00, 0x1AC02400)
__AARCH64_INSN_FUNCS(asrv,	0x7FE0FC00, 0x1AC02800)
__AARCH64_INSN_FUNCS(rorv,	0x7FE0FC00, 0x1AC02C00)
__AARCH64_INSN_FUNCS(rev16,	0x7FFFFC00, 0x5AC00400)
__AARCH64_INSN_FUNCS(rev32,	0x7FFFFC00, 0x5AC00800)
__AARCH64_INSN_FUNCS(rev64,	0x7FFFFC00, 0x5AC00C00)
__AARCH64_INSN_FUNCS(and,	0x7F200000, 0x0A000000)
__AARCH64_INSN_FUNCS(bic,	0x7F200000, 0x0A200000)
__AARCH64_INSN_FUNCS(orr,	0x7F200000, 0x2A000000)
__AARCH64_INSN_FUNCS(mov_reg,	0x7FE0FFE0, 0x2A0003E0)
__AARCH64_INSN_FUNCS(orn,	0x7F200000, 0x2A200000)
__AARCH64_INSN_FUNCS(eor,	0x7F200000, 0x4A000000)
__AARCH64_INSN_FUNCS(eon,	0x7F200000, 0x4A200000)
__AARCH64_INSN_FUNCS(ands,	0x7F200000, 0x6A000000)
__AARCH64_INSN_FUNCS(bics,	0x7F200000, 0x6A200000)
__AARCH64_INSN_FUNCS(and_imm,	0x7F800000, 0x12000000)
__AARCH64_INSN_FUNCS(orr_imm,	0x7F800000, 0x32000000)
__AARCH64_INSN_FUNCS(eor_imm,	0x7F800000, 0x52000000)
__AARCH64_INSN_FUNCS(ands_imm,	0x7F800000, 0x72000000)
__AARCH64_INSN_FUNCS(extr,	0x7FA00000, 0x13800000)
__AARCH64_INSN_FUNCS(b,		0xFC000000, 0x14000000)
__AARCH64_INSN_FUNCS(bl,	0xFC000000, 0x94000000)
__AARCH64_INSN_FUNCS(cbz,	0x7F000000, 0x34000000)
__AARCH64_INSN_FUNCS(cbnz,	0x7F000000, 0x35000000)
__AARCH64_INSN_FUNCS(tbz,	0x7F000000, 0x36000000)
__AARCH64_INSN_FUNCS(tbnz,	0x7F000000, 0x37000000)
__AARCH64_INSN_FUNCS(bcond,	0xFF000010, 0x54000000)
__AARCH64_INSN_FUNCS(svc,	0xFFE0001F, 0xD4000001)
__AARCH64_INSN_FUNCS(hvc,	0xFFE0001F, 0xD4000002)
__AARCH64_INSN_FUNCS(smc,	0xFFE0001F, 0xD4000003)
__AARCH64_INSN_FUNCS(brk,	0xFFE0001F, 0xD4200000)
__AARCH64_INSN_FUNCS(exception,	0xFF000000, 0xD4000000)
__AARCH64_INSN_FUNCS(hint,	0xFFFFF01F, 0xD503201F)
__AARCH64_INSN_FUNCS(br,	0xFFFFFC1F, 0xD61F0000)
__AARCH64_INSN_FUNCS(br_auth,	0xFEFFF800, 0xD61F0800)
__AARCH64_INSN_FUNCS(blr,	0xFFFFFC1F, 0xD63F0000)
__AARCH64_INSN_FUNCS(blr_auth,	0xFEFFF800, 0xD63F0800)
__AARCH64_INSN_FUNCS(ret,	0xFFFFFC1F, 0xD65F0000)
__AARCH64_INSN_FUNCS(ret_auth,	0xFFFFFBFF, 0xD65F0BFF)
__AARCH64_INSN_FUNCS(eret,	0xFFFFFFFF, 0xD69F03E0)
__AARCH64_INSN_FUNCS(eret_auth,	0xFFFFFBFF, 0xD69F0BFF)
__AARCH64_INSN_FUNCS(mrs,	0xFFF00000, 0xD5300000)
__AARCH64_INSN_FUNCS(msr_imm,	0xFFF8F01F, 0xD500401F)
__AARCH64_INSN_FUNCS(msr_reg,	0xFFF00000, 0xD5100000)
__AARCH64_INSN_FUNCS(dmb,	0xFFFFF0FF, 0xD50330BF)
__AARCH64_INSN_FUNCS(dsb_base,	0xFFFFF0FF, 0xD503309F)
__AARCH64_INSN_FUNCS(dsb_nxs,	0xFFFFF3FF, 0xD503323F)
__AARCH64_INSN_FUNCS(isb,	0xFFFFF0FF, 0xD50330DF)
__AARCH64_INSN_FUNCS(sb,	0xFFFFFFFF, 0xD50330FF)
__AARCH64_INSN_FUNCS(clrex,	0xFFFFF0FF, 0xD503305F)
__AARCH64_INSN_FUNCS(ssbb,	0xFFFFFFFF, 0xD503309F)
__AARCH64_INSN_FUNCS(pssbb,	0xFFFFFFFF, 0xD503349F)
__AARCH64_INSN_FUNCS(bti,	0xFFFFFF3F, 0xD503241f)

enum aarch64_insn_hint_cr_op {
	AARCH64_INSN_HINT_NOP	= 0x0 << 5,
	AARCH64_INSN_HINT_YIELD	= 0x1 << 5,
	AARCH64_INSN_HINT_WFE	= 0x2 << 5,
	AARCH64_INSN_HINT_WFI	= 0x3 << 5,
	AARCH64_INSN_HINT_SEV	= 0x4 << 5,
	AARCH64_INSN_HINT_SEVL	= 0x5 << 5,

	AARCH64_INSN_HINT_XPACLRI    = 0x07 << 5,
	AARCH64_INSN_HINT_PACIA_1716 = 0x08 << 5,
	AARCH64_INSN_HINT_PACIB_1716 = 0x0A << 5,
	AARCH64_INSN_HINT_AUTIA_1716 = 0x0C << 5,
	AARCH64_INSN_HINT_AUTIB_1716 = 0x0E << 5,
	AARCH64_INSN_HINT_PACIAZ     = 0x18 << 5,
	AARCH64_INSN_HINT_PACIASP    = 0x19 << 5,
	AARCH64_INSN_HINT_PACIBZ     = 0x1A << 5,
	AARCH64_INSN_HINT_PACIBSP    = 0x1B << 5,
	AARCH64_INSN_HINT_AUTIAZ     = 0x1C << 5,
	AARCH64_INSN_HINT_AUTIASP    = 0x1D << 5,
	AARCH64_INSN_HINT_AUTIBZ     = 0x1E << 5,
	AARCH64_INSN_HINT_AUTIBSP    = 0x1F << 5,

	AARCH64_INSN_HINT_ESB  = 0x10 << 5,
	AARCH64_INSN_HINT_PSB  = 0x11 << 5,
	AARCH64_INSN_HINT_TSB  = 0x12 << 5,
	AARCH64_INSN_HINT_CSDB = 0x14 << 5,
	AARCH64_INSN_HINT_CLEARBHB = 0x16 << 5,

	AARCH64_INSN_HINT_BTI   = 0x20 << 5,
	AARCH64_INSN_HINT_BTIC  = 0x22 << 5,
	AARCH64_INSN_HINT_BTIJ  = 0x24 << 5,
	AARCH64_INSN_HINT_BTIJC = 0x26 << 5,
};

static bool aarch64_insn_is_steppable_hint(uint32_t insn)
{
	if (!aarch64_insn_is_hint(insn))
		return false;

	switch (insn & 0xFE0) {
	case AARCH64_INSN_HINT_XPACLRI:
	case AARCH64_INSN_HINT_PACIA_1716:
	case AARCH64_INSN_HINT_PACIB_1716:
	case AARCH64_INSN_HINT_PACIAZ:
	case AARCH64_INSN_HINT_PACIASP:
	case AARCH64_INSN_HINT_PACIBZ:
	case AARCH64_INSN_HINT_PACIBSP:
	case AARCH64_INSN_HINT_BTI:
	case AARCH64_INSN_HINT_BTIC:
	case AARCH64_INSN_HINT_BTIJ:
	case AARCH64_INSN_HINT_BTIJC:
	case AARCH64_INSN_HINT_NOP:
		return true;
	default:
		return false;
	}
}

static bool aarch64_insn_is_branch(uint32_t insn)
{
	/* b, bl, cb*, tb*, ret*, b.cond, br*, blr* */
	return aarch64_insn_is_b(insn) ||
	       aarch64_insn_is_bl(insn) ||
	       aarch64_insn_is_cbz(insn) ||
	       aarch64_insn_is_cbnz(insn) ||
	       aarch64_insn_is_tbz(insn) ||
	       aarch64_insn_is_tbnz(insn) ||
	       aarch64_insn_is_ret(insn) ||
	       aarch64_insn_is_ret_auth(insn) ||
	       aarch64_insn_is_br(insn) ||
	       aarch64_insn_is_br_auth(insn) ||
	       aarch64_insn_is_blr(insn) ||
	       aarch64_insn_is_blr_auth(insn) ||
	       aarch64_insn_is_bcond(insn);
}

static bool aarch64_insn_is_adr_adrp(uint32_t insn)
{
	return aarch64_insn_is_adr(insn) ||
	       aarch64_insn_is_adrp(insn);
}

static bool aarch64_insn_uses_literal(uint32_t insn)
{
	/* ldr/ldrsw (literal), prfm */

	return aarch64_insn_is_ldr_lit(insn) ||
	       aarch64_insn_is_ldrsw_lit(insn) ||
	       aarch64_insn_is_adr_adrp(insn) ||
	       aarch64_insn_is_prfm_lit(insn);
}

/*
 * Extract the Op/CR data from a msr/mrs instruction.
 */
static uint32_t aarch64_insn_extract_system_reg(uint32_t insn)
{
	return (insn & 0x1FFFE0) >> 5;
}
